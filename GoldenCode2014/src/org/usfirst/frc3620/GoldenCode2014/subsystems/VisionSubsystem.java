// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3620.GoldenCode2014.subsystems;

import com.sun.squawk.microedition.io.FileConnection;
import edu.wpi.first.wpilibj.DriverStationLCD;
import edu.wpi.first.wpilibj.camera.AxisCamera;
import edu.wpi.first.wpilibj.camera.AxisCameraException;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.image.BinaryImage;
import edu.wpi.first.wpilibj.image.ColorImage;
import edu.wpi.first.wpilibj.image.CriteriaCollection;
import edu.wpi.first.wpilibj.image.NIVision;
import edu.wpi.first.wpilibj.image.NIVisionException;
import edu.wpi.first.wpilibj.image.ParticleAnalysisReport;
import edu.wpi.first.wpilibj.image.RGBImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.TimerTask;
import javax.microedition.io.Connector;
import org.usfirst.frc3620.GoldenCode2014.PreferencesNames;
import org.usfirst.frc3620.GoldenCode2014.Robot;

/**
 *
 */
public class VisionSubsystem extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    java.util.Timer timer;

    public VisionSubsystem() {
        super();
        timer = new java.util.Timer();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    //Camera constants used for distance calculation
    final int Y_IMAGE_RES = 480;		//X Image resolution in pixels, should be 120, 240 or 480
    final double VIEW_ANGLE = 49;		//Axis M1013
    //final double VIEW_ANGLE = 41.7;		//Axis 206 camera
    //final double VIEW_ANGLE = 37.4;  //Axis M1011 camera
    final double PI = 3.141592653;
    //Score limits used for target identification
    final int RECTANGULARITY_LIMIT = 40;
    final int ASPECT_RATIO_LIMIT = 55;
    //Score limits used for hot target determination
    final int TAPE_WIDTH_LIMIT = 50;
    final int VERTICAL_SCORE_LIMIT = 50;
    final int LR_SCORE_LIMIT = 50;
    //Minimum area of particles to be considered
    final int AREA_MINIMUM = 150;
    //Maximum number of particles to process
    final int MAX_PARTICLES = 8;
    AxisCamera camera;          // the axis camera object (connected to the switch)
    CriteriaCollection cc;      // the criteria for doing the particle filter operation

    public class Scores {

        double rectangularity;
        double aspectRatioVertical;
        double aspectRatioHorizontal;
    }

    public class TargetReport {

        int verticalIndex;
        int horizontalIndex;
        boolean Hot;
        double totalScore;
        double leftScore;
        double rightScore;
        double tapeWidthScore;
        double verticalScore;
    };

    public boolean isHot(String inputFile) {
        System.out.println("entering isHot");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream out = new PrintStream(baos);
        long t0 = System.currentTimeMillis();
        try {
            boolean rv = false;
            TargetReport target = new TargetReport();
            int verticalTargets[] = new int[MAX_PARTICLES];
            int horizontalTargets[] = new int[MAX_PARTICLES];
            int verticalTargetCount, horizontalTargetCount;
            ColorImage image = null;
            BinaryImage thresholdImage = null;
            BinaryImage filteredImage = null;
            try {
                /**
                 * Do the image capture with the camera and apply the algorithm
                 * described above. This sample will either get images from the
                 * camera or from an image file stored in the top level
                 * directory in the flash memory on the cRIO. The file name in
                 * this case is "testImage.jpg"
                 *
                 */
                if (inputFile != null) {
                    image = new RGBImage(inputFile);		// get the sample image from the cRIO flash
                } else {
                    if (camera != null) {
                        image = camera.getImage();
                        image.write("/captured.bmp");
                    } else {
                        System.out.println("camera is diabled");
                    }
                }
                //thresholdImage = image.thresholdHSV(105, 137, 230, 255, 133, 183);   // keep only green objects
                // camera settings:
                // color leve = 82
                // brightness = 10
                // shaprness = 50
                // contrast = 50
                // exposure value = 3
                int hueLower = Robot.preferences.getInt(PreferencesNames.HUE_LOWER, 67);
                int hueUpper = Robot.preferences.getInt(PreferencesNames.HUE_UPPER, 143);
                int saturationLower = Robot.preferences.getInt(PreferencesNames.SATURATION_LOWER, 199);
                int saturationUpper = Robot.preferences.getInt(PreferencesNames.SATURATION_UPPER, 255);
                int valueLower = Robot.preferences.getInt(PreferencesNames.VALUE_LOWER, 76);
                int valueUpper = Robot.preferences.getInt(PreferencesNames.VALUE_UPPER, 255);
                thresholdImage = image.thresholdHSV(hueLower, hueUpper, saturationLower, saturationUpper, valueLower, valueUpper);
                out.println("threshold parameters = " + hueLower + "," + hueUpper + "," + saturationLower + "," + saturationUpper + "," + valueLower + "," + valueUpper);
                thresholdImage.write("/threshold.bmp");
                filteredImage = thresholdImage.particleFilter(cc);           // filter out small particles
                filteredImage.write("/filteredImage.bmp");
                //iterate through each particle and score to see if it is a target
                Scores scores[] = new Scores[filteredImage.getNumberParticles()];
                horizontalTargetCount = verticalTargetCount = 0;
                if (filteredImage.getNumberParticles() > 0) {
                    for (int i = 0; i < MAX_PARTICLES && i < filteredImage.getNumberParticles(); i++) {
                        ParticleAnalysisReport report = filteredImage.getParticleAnalysisReport(i);
                        scores[i] = new Scores();
                        //Score each particle on rectangularity and aspect ratio
                        scores[i].rectangularity = scoreRectangularity(report);
                        scores[i].aspectRatioVertical = scoreAspectRatio(filteredImage, report, i, true);
                        scores[i].aspectRatioHorizontal = scoreAspectRatio(filteredImage, report, i, false);
                        //Check if the particle is a horizontal target, if not, check if it's a vertical target
                        if (scoreCompare(scores[i], false)) {
                            if (out != null) {
                                out.println("particle: " + i + " is a Horizontal Target centerX: " + report.center_mass_x + " centerY: " + report.center_mass_y);
                            }
                            System.out.println("particle: " + i + " is a Horizontal Target centerX: " + report.center_mass_x + " centerY: " + report.center_mass_y);
                            horizontalTargets[horizontalTargetCount++] = i; //Add particle to target array and increment count
                        } else if (scoreCompare(scores[i], true)) {
                            if (out != null) {
                                out.println("particle: " + i + " is a Vertical Target centerX: " + report.center_mass_x + " centerY: " + report.center_mass_y);
                            }
                            System.out.println("particle: " + i + " is a Vertical Target centerX: " + report.center_mass_x + " centerY: " + report.center_mass_y);
                            verticalTargets[verticalTargetCount++] = i;  //Add particle to target array and increment count
                        } else {
                            if (out != null) {
                                out.println("particle: " + i + " is not a Target centerX: " + report.center_mass_x + " centerY: " + report.center_mass_y);
                            }
                            System.out.println("particle: " + i + " is not a Target centerX: " + report.center_mass_x + " centerY: " + report.center_mass_y);
                        }
                        if (out != null) {
                            out.println("rect: " + scores[i].rectangularity + "ARHoriz: " + scores[i].aspectRatioHorizontal);
                        }
                        System.out.println("rect: " + scores[i].rectangularity + "ARHoriz: " + scores[i].aspectRatioHorizontal);
                        if (out != null) {
                            out.println("ARVert: " + scores[i].aspectRatioVertical);
                        }
                        System.out.println("ARVert: " + scores[i].aspectRatioVertical);
                    }
                    //Zero out scores and set verticalIndex to first target in case there are no horizontal targets
                    target.totalScore = target.leftScore = target.rightScore = target.tapeWidthScore = target.verticalScore = 0;
                    target.verticalIndex = verticalTargets[0];
                    for (int i = 0; i < verticalTargetCount; i++) {
                        ParticleAnalysisReport verticalReport = filteredImage.getParticleAnalysisReport(verticalTargets[i]);
                        for (int j = 0; j < horizontalTargetCount; j++) {
                            ParticleAnalysisReport horizontalReport = filteredImage.getParticleAnalysisReport(horizontalTargets[j]);
                            double horizWidth, horizHeight, vertWidth, leftScore, rightScore, tapeWidthScore, verticalScore, total;
                            //Measure equivalent rectangle sides for use in score calculation
                            horizWidth = NIVision.MeasureParticle(filteredImage.image, horizontalTargets[j], false, NIVision.MeasurementType.IMAQ_MT_EQUIVALENT_RECT_LONG_SIDE);
                            vertWidth = NIVision.MeasureParticle(filteredImage.image, verticalTargets[i], false, NIVision.MeasurementType.IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE);
                            horizHeight = NIVision.MeasureParticle(filteredImage.image, horizontalTargets[j], false, NIVision.MeasurementType.IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE);
                            //Determine if the horizontal target is in the expected location to the left of the vertical target
                            leftScore = ratioToScore(1.2 * (verticalReport.boundingRectLeft - horizontalReport.center_mass_x) / horizWidth);
                            //Determine if the horizontal target is in the expected location to the right of the  vertical target
                            rightScore = ratioToScore(1.2 * (horizontalReport.center_mass_x - verticalReport.boundingRectLeft - verticalReport.boundingRectWidth) / horizWidth);
                            //Determine if the width of the tape on the two targets appears to be the same
                            tapeWidthScore = ratioToScore(vertWidth / horizHeight);
                            //Determine if the vertical location of the horizontal target appears to be correct
                            verticalScore = ratioToScore(1 - (verticalReport.boundingRectTop - horizontalReport.center_mass_y) / (4 * horizHeight));
                            total = leftScore > rightScore ? leftScore : rightScore;
                            total += tapeWidthScore + verticalScore;
                            //If the target is the best detected so far store the information about it
                            if (total > target.totalScore) {
                                target.horizontalIndex = horizontalTargets[j];
                                target.verticalIndex = verticalTargets[i];
                                target.totalScore = total;
                                target.leftScore = leftScore;
                                target.rightScore = rightScore;
                                target.tapeWidthScore = tapeWidthScore;
                                target.verticalScore = verticalScore;
                            }
                        }
                        //Determine if the best target is a Hot target
                        target.Hot = hotOrNot(target);
                    }
                    if (verticalTargetCount > 0) {
                        if (target.Hot) {
                            out.println("Hot target located");;
                            System.out.println("Hot target located");
                            rv = true;
                        } else {
                            out.println("No hot target located");;
                            System.out.println("No hot target present");
                        }
                    }
                }
                if (out != null) {
                    out.println("it took " + (System.currentTimeMillis() - t0) + " millis");
                }
            } catch (AxisCameraException ex) {        // this is needed if the camera.getImage() is called
                ex.printStackTrace();
            } catch (NIVisionException ex) {
                ex.printStackTrace();
            } finally {
                /**
                 * all images in Java must be freed after they are used since
                 * they are allocated out of C data structures. Not calling
                 * free() will cause the memory to accumulate over each pass of
                 * this loop.
                 */
                try {
                    if (filteredImage != null) {
                        filteredImage.free();
                    }
                } catch (NIVisionException ex) {
                    // can't do anything about it!
                }
                try {
                    if (thresholdImage != null) {
                        thresholdImage.free();
                    }
                } catch (NIVisionException ex) {
                    // can't do anything about it!
                }
                try {
                    if (image != null) {
                        image.free();
                    }
                } catch (NIVisionException ex) {
                    // can't do anything about it!
                }
                // write to file at end. the camera open seems to fail if we open the
                // file at the beginning of this routines and keep it open
                out.close();
                FileConnection file = null;
                try {
                    file = (FileConnection) Connector.open("file:///index.html", Connector.WRITE);
                    file.create();
                    OutputStream os = file.openOutputStream();
                    String s = "<HTML><BODY>captured<BR><IMG SRC=\"captured.bmp\"><br>\n"
                            + "thresholded<BR><IMG SRC=\"threshold.bmp\"><br>\n"
                            + "filtered<BR><IMG SRC=\"filteredImage.bmp\"><br>\n"
                            + "<PRE>";
                    os.write(s.getBytes());
                    os.write(baos.toByteArray());
                    s = "</PRE></BODY></HTML>";
                    os.write(s.getBytes());
                    os.close();
                } catch (IOException ex) {
                    ex.printStackTrace();
                } finally {
                    if (file != null) {
                        try {
                            file.close();
                        } catch (IOException ex) {
                        }
                    }
                }
            }
            return rv;
        } catch (Exception ex) {
            // make sure we keep working!
            ex.printStackTrace();
            return false;
        }
    }

    /**
     * Compares scores to defined limits and returns true if the particle
     * appears to be a target
     *
     * @param scores The structure containing the scores to compare
     * @param outer True if the particle should be treated as an outer target,
     * false to treat it as a center target
     *
     * @return True if the particle meets all limits, false otherwise
     */
    boolean scoreCompare(Scores scores, boolean vertical) {
        boolean isTarget = true;
        isTarget &= scores.rectangularity > RECTANGULARITY_LIMIT;
        if (vertical) {
            isTarget &= scores.aspectRatioVertical > ASPECT_RATIO_LIMIT;
        } else {
            isTarget &= scores.aspectRatioHorizontal > ASPECT_RATIO_LIMIT;
        }
        return isTarget;
    }

    /**
     * Takes in a report on a target and compares the scores to the defined
     * score limits to evaluate if the target is a hot target or not.
     *
     * Returns True if the target is hot. False if it is not.
     */
    boolean hotOrNot(TargetReport target) {
        boolean isHot = true;
        isHot &= target.tapeWidthScore >= TAPE_WIDTH_LIMIT;
        isHot &= target.verticalScore >= VERTICAL_SCORE_LIMIT;
        isHot &= (target.leftScore > LR_SCORE_LIMIT) | (target.rightScore > LR_SCORE_LIMIT);
        return isHot;
    }

    /**
     * Computes a score (0-100) estimating how rectangular the particle is by
     * comparing the area of the particle to the area of the bounding box
     * surrounding it. A perfect rectangle would cover the entire bounding box.
     *
     * @param report The Particle Analysis Report for the particle to score
     * @return The rectangularity score (0-100)
     */
    double scoreRectangularity(ParticleAnalysisReport report) {
        if (report.boundingRectWidth * report.boundingRectHeight != 0) {
            return 100 * report.particleArea / (report.boundingRectWidth * report.boundingRectHeight);
        } else {
            return 0;
        }
    }

    /**
     * Converts a ratio with ideal value of 1 to a score. The resulting function
     * is piecewise linear going from (0,0) to (1,100) to (2,0) and is 0 for all
     * inputs outside the range 0-2
     */
    double ratioToScore(double ratio) {
        return (Math.max(0, Math.min(100 * (1 - Math.abs(1 - ratio)), 100)));
    }

    /**
     * Computes a score (0-100) comparing the aspect ratio to the ideal aspect
     * ratio for the target. This method uses the equivalent rectangle sides to
     * determine aspect ratio as it performs better as the target gets skewed by
     * moving to the left or right. The equivalent rectangle is the rectangle
     * with sides x and y where particle area= x*y and particle perimeter= 2x+2y
     *
     * @param image The image containing the particle to score, needed to
     * perform additional measurements
     * @param report The Particle Analysis Report for the particle, used for the
     * width, height, and particle number
     * @param outer	Indicates whether the particle aspect ratio should be
     * compared to the ratio for the inner target or the outer
     * @return The aspect ratio score (0-100)
     */
    public double scoreAspectRatio(BinaryImage image, ParticleAnalysisReport report, int particleNumber, boolean vertical) throws NIVisionException {
        double rectLong, rectShort, aspectRatio, idealAspectRatio;
        rectLong = NIVision.MeasureParticle(image.image, particleNumber, false, NIVision.MeasurementType.IMAQ_MT_EQUIVALENT_RECT_LONG_SIDE);
        rectShort = NIVision.MeasureParticle(image.image, particleNumber, false, NIVision.MeasurementType.IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE);
        idealAspectRatio = vertical ? (4.0 / 32) : (23.5 / 4);	//Vertical reflector 4" wide x 32" tall, horizontal 23.5" wide x 4" tall
        //Divide width by height to measure aspect ratio
        if (report.boundingRectWidth > report.boundingRectHeight) {
            //particle is wider than it is tall, divide long by short
            aspectRatio = ratioToScore((rectLong / rectShort) / idealAspectRatio);
        } else {
            //particle is taller than it is wide, divide short by long
            aspectRatio = ratioToScore((rectShort / rectLong) / idealAspectRatio);
        }
        return aspectRatio;
    }

    /**
     * add any needed code to run when robot powers up.
     */
    public void init() {
        camera = AxisCamera.getInstance();  // get an instance of the camera
        cc = new CriteriaCollection();      // create the criteria for the particle filter
        cc.addCriteria(NIVision.MeasurementType.IMAQ_MT_AREA, AREA_MINIMUM, 65535, false);
    }

    /**
     * add any needed code to run if the mode changes.
     */
    public void modeChanged() {
    }

    /**
     * add any needed code to run everytime periodic is called.
     */
    public void periodic() {
    }
    boolean goalIsHot = false;

    public void processOne(final String inputFile) {
        try {
            setGoalIsHot(false);
            Robot.driverStationLCD.println(DriverStationLCD.Line.kUser1, 1, "Starting vision");
            Robot.driverStationLCD.updateLCD();
            TimerTask timerTask = new TimerTask() {
                public void run() {
                    boolean b = isHot(inputFile);
                    setGoalIsHot(b);
                    Robot.driverStationLCD.println(DriverStationLCD.Line.kUser1, 1, "goal = " + ( b ? "seen" : "not seen"));
                    Robot.driverStationLCD.updateLCD();
                }
            };
            timer.schedule(timerTask, 750);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public boolean isGoalIsHot() {
        return goalIsHot;
    }

    public void setGoalIsHot(boolean goalIsHot) {
        this.goalIsHot = goalIsHot;
    }
}
